\documentclass[letter]{amsart}
\usepackage[pdftex]{geometry}
\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{courier}
\usepackage{fancyhdr}
\usepackage[final]{pdfpages}

\lstset{language=C++}
\lstset{columns=fullflexible}
\lstset{basicstyle=\scriptsize\ttfamily}
\lstset{showspaces=false}

\geometry{landscape}
\setlength{\textheight}{200mm}
\setlength{\topmargin}{-0.90in}
\setlength{\oddsidemargin}{-0.6in}
\setlength{\evensidemargin}{-0.6in}
\setlength{\columnsep}{0.6in}
\setlength{\columnseprule}{0.5pt}
\textwidth 10in

\pagestyle{fancy}
\lhead{ Universidad de la Habana: UH Top }
\chead{}
\rhead{\thepage}
\lfoot{}
\cfoot{}
\rfoot{}

\newcommand{\includecpp}[3]{
  \begin{multicols}{2}
    [\subsection{#1}\ ]
    \lstinputlisting[language=c++]{#2/#3}
  \end{multicols}
}

\newcommand{\stirlingfirst}[2]{\genfrac{[}{]}{0pt}{}{#1}{#2}}
\newcommand{\stirlingsecond}[2]{\genfrac{\{}{\}}{0pt}{}{#1}{#2}}
\newcommand{\norm}[1]{\lVert#1\rVert}

\begin{document}
  \thispagestyle{fancy}
  \begin{center}
    \Huge\textsc{Team Reference Universidad de la Habana: UH Top }
  \end{center}
  
  \begin{center}
    \textbf{ ICPC World Finals 2021 }\\
    \textbf{Team Members:} L\'azaro Ra\'ul Iglesias Vera, David Manuel Garc\'ia Aguilera, Denis G\'omez Cruz
  \end{center}  

  \begin{multicols}{2}
    \tableofcontents
  \end{multicols}

  \enlargethispage*{\baselineskip}
  % \pagebreak

  \section{ Data Structures }
    \includecpp {Convex Hull Trick}{./data_structures}{_convex_hull_trick_set.cpp}
    \includecpp {Order Statistics}{./data_structures}{_order_statistic.cpp}
    \includecpp {Treap}{./data_structures}{_treap.cpp}
    \includecpp {PST}{./data_structures}{persistent_ST(usando_pool)(dmga44).cpp}
    \includecpp {Queue Undo Trick}{./data_structures}{Queue_Undo_Trick(Devil).cpp}
    
  \enlargethispage*{\baselineskip}

  \section{ Geometry }
     \includecpp {Antipodal Points}{./geometry}{_antipodal_points.cpp}
  	 \includecpp {Basics Complex}{./geometry}{_basics_complex.cpp}
     \includecpp {Circle}{./geometry}{_circle.cpp}
  	 \includecpp {Closest pair Points}{./geometry}{_closest_pair_points.cpp}
     \includecpp {Contains}{./geometry}{_contains.cpp}
     \includecpp {Line Segment Intersections}{./geometry}{_line_segment_intersections.cpp}
     \includecpp {Minkowski}{./geometry}{_minkowski.cpp}
     \includecpp {Rectangle union}{./geometry}{_rectangle_union.cpp}
     \includecpp {Polygon Area}{./geometry}{area2_pol.cpp}
     \includecpp {Mass Center}{./geometry}{centroid.cpp}
     \includecpp {Convex Cut}{./geometry}{convex_cut.cpp}
     \includecpp {Convex Hull}{./geometry}{convex_hull.cpp}
     \includecpp {Polygon Width}{./geometry}{polygon_width.cpp}
     \includecpp {Semiplane Intersection}{./geometry}{semiplane_intersection.cpp}
    

  \enlargethispage*{\baselineskip}

  \section{ Graph }
     \includecpp {Articulation Points}{./graph}{_arts_bridges_biconnected.cpp}
     \includecpp {Bipartite Matching}{./graph}{_bipartite_matching.cpp}
     \includecpp {Centroid Decomposition}{./graph}{_centroid_decomposition.cpp}
     \includecpp {Dinic}{./graph}{_dinic.cpp}
     \includecpp {Eulerian graph}{./graph}{_eulerian_graph.cpp}
     \includecpp {Heavy light decomposition}{./graph}{_heavy_light_decomposition.cpp}
     \includecpp {Min Cost Flow}{./graph}{_min_cost_flow.cpp}
     \includecpp {2-SAT}{./graph}{_sat2.cpp}
     \includecpp {Strongly connected components}{./graph}{_strongly_connected_component.cpp}
     \includecpp {Virtual tree}{./graph}{_virtual_tree.cpp}
     \includecpp {Gomory Hu Tree}{./graph}{gomory_hu_tree.cpp}
    
  
  \enlargethispage*{\baselineskip}

  \section{ Math }
     \includecpp {Bitwise transform}{./math}{_bitwise_transform.cpp}
     \includecpp {Simplex}{./math}{_simplex.cpp}
     \includecpp {Number theoretic transform}{./math}{_number_theoretic_transform.cpp}
     \includecpp {Gauss}{./math}{gauss.cpp}
     \includecpp {Hungarian}{./math}{hungarian.cpp}
     \includecpp {Integrate}{./math}{integrate.cpp}
     \includecpp {NTT with arbitrary mod}{./math}{number_theoretic_transform_arbitrary_mod.cpp}
     \includecpp {Interpolation}{./math}{interpolation.cpp}
     

  \enlargethispage*{\baselineskip}

  \section{ Number Theory }
     \includecpp {Diophantine Equation}{./number_theory}{_extended_euclid_and_diophantine_equation.cpp}
     \includecpp {Miller Rabin}{./number_theory}{_miller_rabin.cpp}
     \includecpp {Pollard Rho}{./number_theory}{_pollard_rho.cpp}
     \includecpp {Chinese Remainder Theorem}{./number_theory}{chinese_remainder_theorem.cpp}
     \includecpp {Discrete Logarithm}{./number_theory}{discrete_logarithm.cpp}
     \includecpp {Discrete Roots}{./number_theory}{discrete_roots.cpp}
     \includecpp {Modular Arithmetics}{./number_theory}{modular_arithmetics.cpp}
     \includecpp {Primitive Root}{./number_theory}{primitive_root.cpp}
  

  \enlargethispage*{\baselineskip}

  \section{ String }
     \includecpp {Suffix Array}{./string}{_suffix_array.cpp}
     \includecpp {Aho-Corasick}{./string}{_aho_corasick.cpp}
     \includecpp {Manacher}{./string}{_manacher.cpp}
     \includecpp {Z Algorithm}{./string}{_z_algorithm.cpp}
     \includecpp {Suffix Tree}{./string}{_suffix_tree.cpp}
     \includecpp {Maximal Suffix}{./string}{maximal_suffix.cpp}
     \includecpp {Minimum Rotation}{./string}{minimum_rotation.cpp}

  \section{ Useful }
    \includecpp {Random}{./useful}{random.cpp}
    \includecpp {Launch Json}{./useful}{launch.json}
    \includecpp {Tasks Json}{./useful}{tasks.json}
    
  \enlargethispage*{\baselineskip}

  \section{ Tips }
  	 \textbf{Mobius Inversion}: $g(n) = \sum_{d|n}f(d) \Leftrightarrow f(n)=\sum_{d|n}\mu(d)g(n/d),~~ \sum_{d|n}\mu(d)=[n == 1],~~ \sum_{d|n}phi(n)=n$\\
  	 \textbf{Vertex Cover}: Sea el grafo bipartito G(L, R). Sea M un matching máximo de G. Busco un corte mínimo. Un cubrimiento mínimo son los extremos de las aristas cortadas que no son s ni t. Sea $U = \{x \in L:~x~no~pertenece~al~matching~M\}$. Sea $Z=\{x:~x~es~alcanzable~desde~U~siguiendo~algun~camino~alternante\}$. Un vertex cover de G es $VC =(L-Z) U (R \cap Z)$. $|VC| = |M|$.\\
  	 \textbf{Maximum Independent Set}:$ MIS = VC^c$. $|MIS| = n - |M|$.\\
  	 \textbf{Edge Cover}: Sea el grafo bipartito G(L, R). Sea M un matching máximo de G. $EC = M +$ (1 arista incidente en cada vértice que no cubra el matching máximo). $|EC| = n - |M|$.\\
  	 \textbf{Mínima descomposición en cadenas}: Duplicar los nodos y colocar las aristas con su correspondiente. Obtener el matching máximo. Reconstruir usando las aristas del matching máximo.\\
	 \textbf{Máxima anticadena}: Duplicar los nodos y colocar las aristas con su correspondiente. Obtenemos un cubrimiento por nodos del grafo. Tomamos los nodos que no tienen ninguna copia en el
cubrimiento.

    \pagebreak
    \includepdf[pages={1}, pagecommand={},offset=1cm 0cm, width=\textwidth, angle=90]{formulas.pdf}
    \pagebreak
    \includepdf[pages={2}, pagecommand={},offset=-1cm 0cm, width=\textwidth, angle=90]{formulas.pdf}
    
  
\end{document}
